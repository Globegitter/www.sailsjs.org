<div class="docs views">
<h1>Views</h1>
<blockquote>
<p><em><strong>Note:</strong> You are viewing the Sails.js v0.9.0 documentation.  If you&#39;re looking for information on v0.8.x, please visit <a href="http://08x.sailsjs.org">here</a>.</em></p>
</blockquote>
<p>There are three kinds of views in Sails. There are traditional view partials, view templates, and
the layout.</p>
<h2>What is a View?</h2>
<p>In Sails a view is the representation of the UI of your application. Views are, by default, EJS (<a href="http://embeddedjs.com/">Embedded JavaScript</a>) files. 
Sails uses EJS, or its other configurable templating libraries, to present your app&#39;s data as HTML. Sails allows you to create templates that are injected into the DOM. 
With this, all you ever have to respond with is JSON objects in your controllers, creating a truly API-driven application.</p>
<h2>Where do I define Views?</h2>
<p>Traditional views are defined in the <code>/views/</code> directory while templates are defined in the 
<code>/assets/templates/</code> directory.</p>
<h2>Server-side Views, Layout, and View Partials</h2>
<p>Server-side views in the <code>/views/</code> directory are by default EJS files that will handle the job
of presenting data when a view requested by the client. The method <code>res.view()</code> call will
respond to a client with the appropriate view.</p>
<p>Here&#39;s an example of a view (views/corndog/index.ejs) that consumes some data sent down from a controller:</p>
<pre><code class="lang-html">&lt;div&gt;
  &lt;h1&gt;My first view&lt;/h1&gt;

  &lt;h2&gt;My corndog collection:&lt;/h2&gt;
  &lt;ul&gt;
    &lt;% _.each(corndogs, function (corndog) { %&gt;
    &lt;li&gt;&lt;%= corndog.name %&gt;&lt;/li&gt;
    &lt;% }) %&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
<p>And here&#39;s what the controller looks like:</p>
<pre><code class="lang-javascript">    var CorndogController = {

        index: function(req, res) {
            return res.view({
                corndogs: [{name: &#39;Hank the Corndog&#39;}, {name: &#39;Lenny the Corndog&#39;}]
            });
        }
    }
    module.exports = CorndogController;</code></pre>
<p>If you need to override a layout for a specific view, you can do so in the res.view call as below:</p>
<pre><code class="lang-javascript">res.view({
  layout: &quot;different_layout&quot;
})</code></pre>
<p>This could be called from any controller output.</p>
<h2>View Partials</h2>
<p>Partials are just like they sound.  A View Partial is only a small part of the overall DOM that you see on your web application.  With that said, a partial is nothing more than another (smaller) EJS file. Lets take a look at a partial from the Sails example, and how we should include it from another EJS file.</p>
<h4><code>/views/site/partials/footer.ejs</code></h4>
<pre><code class="lang-html">&lt;footer&gt;
    &lt;span&gt;
        &lt;div class=&quot;float-right&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;float-left&quot;&gt;
            Balderdash &amp;copy; 2013
        &lt;/div&gt;
        &lt;div class=&quot;clearfix&quot;&gt;
        &lt;/div&gt;
    &lt;/span&gt;
&lt;footer&gt;</code></pre>
<p>As you can see, this is nothing more than a simple EJS file.  Nothing special, nothing magical.</p>
<p>Now, lets call it from our index file.</p>
<h4><code>/views/site/index.ejs</code></h4>
<pre><code class="lang-html">&lt;%- partial(&#39;partials/header&#39;)%&gt;
&lt;%- partial(&#39;partials/page&#39;)%&gt;
&lt;%- partial(&#39;partials/footer&#39;) %&gt;</code></pre>
<p>Boring you say?  Well, maybe.  We don&#39;t have a lot in our index.ejs file, but thats because we don&#39;t need a lot.  We call the partials for the site we need to include.  Simply calling a partial by relative path will have it included at runtime.  This makes our code base very clean and easy to read.</p>
<p>Something a little more complicated?  Sure!  We&#39;ll do a 2 level partial this time.  Using our same index.ejs file lets take a look at the &quot;page&quot; partial.</p>
<h4><code>/views/site/partials/page.ejs</code></h4>
<pre><code class="lang-html">&lt;section id=&quot;section1&quot;&gt;
    &lt;span&gt;
        &lt;%- partial(&#39;sections/about&#39;)%&gt;
    &lt;/span&gt;
&lt;/section&gt;
&lt;section id=&quot;section2&quot;&gt;
    &lt;span&gt;
        &lt;%- partial(&#39;sections/blog&#39;)%&gt;
    &lt;/span&gt;
    &lt;span&gt;
        &lt;%- partial(&#39;sections/chat&#39;)%&gt;
    &lt;/span&gt;
    &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;
&lt;/section&gt;</code></pre>
<p>Still simple, but whats this? We are now including other partials from within our partial?  YES! that is exactly what we are doing.  From what you can see now... we can create a hierarchical system of partials that make it easy to navigate through the files for designers.</p>
<p>Lets take a look at the &quot;about&quot; section.  Since we are dealing with HTML5, we like to name the folders that the partials are held in accordingly.  Why? because it just makes sense!</p>
<h4><code>/views/site/partials/sections/about.ejs</code></h4>
<pre><code class="lang-html">&lt;p&gt;
SailsJS is built on NodeJS for easily building fast, scalable network applications. SailsJS provides a MVC framework perfect for data-intensive real-time applications that run across distributed devices.  SailsJS provides a JSON API right out of the box.&lt;br&gt;
&lt;br&gt;
Current Version: v0.8.82
&lt;/p&gt;</code></pre>
<p>Lets look at this a bit now.  We just included a partial from within another partial.  We can use relative pathing to include and because our <strong>/views/site/partials/page.ejs</strong> page and <strong>/views/site/partials/sections</strong> folder are at the same level in the file system, relative pathing is easy to use.  Simple right?  We thought so, too.</p>
<p>We have a structure that we prefer to use for partials to make things easy to read.  This is by no means a &quot;have-to-use&quot; structure, but we do suggest it, as it is our standard.</p>
<pre><code class="lang-text">PROJECT FOLDER
└── views
    ├── 401.ejs
    ├── 404.ejs
    ├── layout.ejs
    └── &lt;controller&gt;
        ├── index.ejs
        ├── &lt;action&gt;.ejs
        └── partials
            ├── footer.ejs
            ├── header.ejs
            ├── page.ejs
            └── sections
                ├── about.ejs
                ├── blog.ejs
                └── chat.ejs</code></pre>
<p>This layout makes it really simple to navigate and keep things organized.</p>
<h2>View Engine Configuration</h2>
<p>One of the benefits of Sails is flexability.  Sails&#39; views system allows for other templating engines than the default (EJS).  The Jade Node Template Engine is available for use as well.  Just install it via <em>npm</em> and just change the engine in <strong>/config/views.js</strong>, or use <code>sails new appname --template=jade</code> for new projects.</p>
<h2>What about using multiple layouts?</h2>
<p>Express 3 removed native support for layouts.  In Sails, we&#39;ve managed to keep this around, but we don&#39;t officially support multiple layouts.</p>
<p>That said, at least in EJS, instead of indicating your custom layout with the <code>layout</code> local,
you must use <code>_layoutFile</code>:</p>
<pre><code class="lang-javascript">res.view({
  _layoutFile: &#39;relativePathToYourCustomLayoutFromTheTargetView.ejs&#39;
});</code></pre>
<p>The path to the layout you&#39;re wanting to use should be specified  <strong>relative</strong> to the view you&#39;re rendering.</p>
<p>So if you&#39;re in the create action of the UserController, rendering a view (<code>views/user/create.ejs</code>), the relative path to your custom layout might be: <code>../staticSiteLayout.ejs</code></p>
<pre><code class="lang-text">PROJECT FOLDER
└── views
    ├── staticSiteLayout.ejs
    ├── layout.ejs
    └── user
        └── create.ejs</code></pre>

</div>