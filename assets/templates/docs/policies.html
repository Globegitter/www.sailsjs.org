<div class="docs policies">
<h1>Policies (ACL)</h1>
<blockquote>
<p><em><strong>Note:</strong> You are viewing the Sails.js v0.9.0 documentation.  If you&#39;re looking for information on v0.8.x, please visit <a href="http://08x.sailsjs.org">here</a>.</em></p>
</blockquote>
<p>So, you don&rsquo;t want your mom to access your secret stash of ... code?  Here&#39;s how you can make that happen. </p>
<h2>What Are Policies?</h2>
<p>Policies in Sails are versatile tools for authorization and access control-- they let you allow or deny access to your controllers down to a fine level of granularity.  For example, if you were building Dropbox, before letting a user upload a file to a folder, you might check that she <code>isAuthenticated</code>, then ensure that she <code>canWrite</code> (has write permissions on the folder.)  Finally, you&#39;d want to check that the folder she&#39;s uploading into <code>hasEnoughSpace</code>.</p>
<p>Policies can be used for anything: HTTP BasicAuth, 3rd party single-sign-on, OAuth 2.0, or your own custom authorization/authentication scheme.</p>
<h2>Writing Your First Policy</h2>
<p>Policies are files defined in the <code>api/policies</code> folder in your Sails app.  Each policy file should contain a single function.</p>
<p>When it comes down to it, policies are really just Connect/Express middleware functions which run <strong>before</strong> your controllers.  You can chain as many of them together as you like-- in fact they&#39;re designed to be used this way.  Ideally, each middleware function should really check just <em>one thing</em>.</p>
<p>For example, the <code>canWrite</code> policy mentioned above might look something like this:</p>
<pre><code class="lang-javascript">// policies/canWrite.js
module.exports = function canWrite (req, res, next) {
  var targetFolderId = req.param(&#39;id&#39;);
  var userId = req.session.user.id;

  Permission
  .findOneByFolderId( targetFolderId )
  .exec( function foundPermission (err, permission) {

    // Unexpected error occurred-- skip to the app&#39;s default error (500) handler
    if (err) return next(err);

    // No permission exists linking this user to this folder.  Maybe they got removed from it?  Maybe they never had permission in the first place?  Who cares?
    if ( ! permission ) return res.redirect(&#39;/notAllowed&#39;);

    // OK, so a permission was found.  Let&#39;s be sure it&#39;s a &quot;write&quot;.
    if ( permission.type !== &#39;write&#39; ) return res.redirect(&#39;/notAllowed&#39;);

    // If we made it all the way down here, looks like everything&#39;s ok, so we&#39;ll let the user through
    next();
  });
};</code></pre>
<h2>How do I protect my controllers with policies?</h2>
<p>Sails has a built in ACL (access control list) located in <code>config/policies.js</code>.  This file is used to map policies to your controllers.  </p>
<p>This file is  <em>declarative</em>, meaning it describes <em>what</em> the permissions for your app should look like, not <em>how</em> they should work.  Declarative programming has many benefits, but in particular, it is both conventional and adaptable.  This makes it easier for new developers to jump in and understand what&#39;s going on, plus it makes your app more flexible as your requirements inevitably change over time.</p>
<p>You can apply one or more policies to a given controller or action.  Any file in your <code>/policies</code> folder (e.g. <code>authenticated.js</code>) is referable in your ACL (<code>config/policies.js</code>) by its filename minus the extension, (e.g.  <code>&#39;authenticated&#39;</code>).  </p>
<p>Additionally, there are a few special, built-in policy mappings:
  + <code>true</code>: public access  (allows anyone to get to the mapped controller/action)
  +  <code>false</code>: <strong>NO</strong> access (allows <strong>no-one</strong> to access the mapped controller/action)</p>
<p> <code>&#39;*&#39;: true</code> is the default policy for all controllers and actions.  In production, it&#39;s good practice to set this to <code>false</code> to prevent access to any logic you might have inadvertently exposed.</p>
<h3>Here&rsquo;s an example of adding some policies to a controller:</h3>
<pre><code class="lang-javascript">    RabbitController: {

        // Apply the `false` policy as the default for all of RabbitController&#39;s actions
        // (`false` prevents all access, which ensures that nothing bad happens to our rabbits)
        &#39;*&#39;: false,

        // For the action `nurture`, apply the &#39;isRabbitMother&#39; policy 
        // (this overrides `false` above)
        nurture    : &#39;isRabbitMother&#39;,

        // Apply the `isNiceToAnimals` AND `hasRabbitFood` policies
        // before letting any users feed our rabbits
        feed : [&#39;isNiceToAnimals&#39;, &#39;hasRabbitFood&#39;]
    }</code></pre>
<p>Here&rsquo;s what the <code>isNiceToAnimals</code> policy from above might look like: (this file would be located at <code>policies/isNiceToAnimals.js</code>)</p>
<p>We&rsquo;ll make some educated guesses about whether our system will consider this user someone who is nice to animals.</p>
<pre><code class="lang-javascript">module.exports = function isNiceToAnimals (req, res, next) {

    // `req.session` contains a set of data specific to the user making this request.
    // It&#39;s kind of like our app&#39;s &quot;memory&quot; of the current user.

    // If our user has a history of animal cruelty, not only will we 
    // prevent her from going even one step further (`return`), 
    // we&#39;ll go ahead and redirect her to PETA (`res.redirect`).
    if ( req.session.user.hasHistoryOfAnimalCruelty ) {
        return res.redirect(&#39;http://PETA.org&#39;);
    }

    // If the user has been seen frowning at puppies, we have to assume that
    // they might end up being mean to them, so we&#39;ll 
    if ( req.session.user.frownsAtPuppies ) {
        return res.redirect(&#39;http://www.dailypuppy.com/&#39;);
    }

    // Finally, if the user has a clean record, we&#39;ll call the `next()` function
    // to let them through to the next policy or our controller
    next();
};</code></pre>
<h4>Besides protecting rabbits (while a noble cause, no doubt), here are a few other use cases for policies:</h4>
<ul>
<li>cookie-based authentication</li>
<li>role-based access control</li>
<li>limiting file uploads based on MB quotas</li>
<li>any other kind of authentication scheme you can imagine</li>
</ul>
<h2>What about me?  I&#39;m using Passport?!</h2>
<p>Passport works great with Sails!  In general, since Sails uses Connect/Express at its core, all of the Connect/Express-oriented things work pretty well.  In fact, Sails has no problem interpreting most Express middleware to work with socket.io.</p>
<p>There are a few good examples of this floating around.  Here&#39;s a good one (hasn&#39;t been tested in v0.9.x yet):
<a href="https://gist.github.com/theangryangel/5060446">https://gist.github.com/theangryangel/5060446</a></p>
<p><a href="http://githalytics.com/balderdashy/sails/wiki/policies"><img src="https://cruel-carlota.pagodabox.com/8acf2fc2ca0aca8a3018e355ad776ed7" alt="githalytics.com alpha" title="githalytics.com"></a></p>

</div>